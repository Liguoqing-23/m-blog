# 变量本质

变量是什么？变量到底是什么？

在刚接触 JS 时，往往讲师都是从变量开始讲起，无论是 C/C++ 也好，Java 也罢，知道我接触到了 JS，在 mooc 打开了一节免费的课程，仍然是从变量开始讲起这门语言的基础。

随着不断学习，从编写简单逻辑，到构建复杂业务，我一直在向前走着，似乎提起变量的次数也少了。即便仍然不断写着 `const`、`let`，却是肌肉记忆，大多思考的是变量名如何起的更见名知意，而不是变量前的那个关键字究竟为何。

## 藏躲在背后的空间——内存

谈起变量，便不得不提内存。无论是 C/C++ 还是 JS 还是任何一种语言，内存的什么周期都是分配 (allocate)、使用 (use)、释放 (release)。

在 JS 中，变量被分为了两种，一种是原始类型 (primitive type)，另一种是引用类型 (reference type)。原始类型包括了 `undefined`、`null`、`boolean`、`number`、`string`、`symbol`、`bigint`，引用类型则包括了 `object`、`array`、`function`。

原始类型存在于栈内存 (stack memory)。之所以如此，是从栈的特点考虑的，栈结构性强、内存连续，所以栈内存的分配和释放都很快。但是栈内存的空间是比较小的。

基于此，原始类型的大小是**固定的**，且**值不可变**。修改变量的值，实际上是重新分配了一块内存空间。

```javascript
let a = 1;
let b = a;
b = 2;
```

在这段代码中，a 和 b 都是原始类型，所以 a 和 b 都是存储在栈内存中。下面演示一下程序运行时栈内存的变化：

```javascript
let a = 1;
// stack: a: 1
let b = a;
// stack: a: 1, b: 1
b = 2;
// stack: a: 1, _, b: 2
// stack: a: 1, b: 2
```

-   当 b 被赋值为 a 时，其实是从栈内存中复制了 a 的值，然后将这个值赋给了 b。
-   当 b 被赋值为 2 时，其实是给 b 分配了新的内存空间，而不是修改了原来的内存空间。而 `_` 则是由垃圾回收机制解决的。

引用类型则是存储在堆内存中，堆内存的分配和释放都比较慢，但是堆内存的大小是没有限制的。

在 JS 中，引用类型就是对象 (object)。按照官方的说法，对象是指内存中的可以被标识符应用的一块区域。对象是 JS 中唯一可变的值，意味着对象可以修改内存中的数据。

要解释上面这段话，首先要理解对象是如何存在内存中的。对象是由键值对组成的，存储在堆内存 (heap memory) 中，而对象的引用则是存储在栈内存中的。我们编写程序只能够通过栈内存中的引用来操作堆内存中的对象，而不能直接操作堆内存中的对象。

堆内存的寻址非常快，所以堆内存操作利于对象的增删改查，且堆内存的空间是比较大的。但是堆内存的分配和释放都比较慢。

## 变量在内存中的初始化

JS 定义变量时就已经在内存中分配了空间。对于原始变量类型，如 `n = 123`、`s = "abc"`，变量名和值都存储在栈内存中。对于引用变量类型，如 `o = { name: "a" }`、`a = [1, 2, 3]`，变量名存储在栈内存中，而值则存储在堆内存中。

而函数作为一种特殊的引用类型，其实也是存储在堆内存中的。函数名存储在栈内存中，而函数体则存储在堆内存中。

## 深拷贝、浅拷贝

在 JS 中经常会遇到深拷贝和浅拷贝的问题。深拷贝和浅拷贝的区别在于是否复制了引用类型的值。

```javascript
let a = { name: "a"， age: 18， friend: { name: "b" } };
let c = a;
c.name = "c";
console.log(a.name); // c
```

修改 c 的 name 属性时，实际上是修改了 a 的堆内存中的对象，所以 a 的 name 属性也被修改了。这就是浅拷贝。

```javascript
function deepClone(obj) {
    if (typeof obj !== "object") return obj;
    let result = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key]);
        }
    }
    return result;
}
let a = { name: "a"， age: 18， friend: { name: "b" } };
let b = deepClone(a);
b.friend.name = "c";
console.log(a.friend.name); // b
```

这段代码使用了递归的方式实现了深拷贝。修改 b 的 friend.name 属性时，实际上是修改了 b 的堆内存中的对象，所以 a 的 friend.name 属性没有被修改。这就是深拷贝。

当然这只是用 `typeof` 简单实现了深拷贝，实际上 `typeof` 也是有局限性的，比如 `typeof null` 会返回 `object`，所以这段代码并不是完全正确的。

深拷贝是一个非常复杂的问题，有很多种实现方式，比如 JSON.parse(JSON.stringify(obj))、lodash 的 _.cloneDeep(obj) 等，往后可以再深入研究。

## 变量的内存释放

JS 如同 JVM 一样，嵌入了垃圾回收机制。垃圾回收机制主要任务是跟踪内存的分配和使用，它会在内存不再使用时，自动释放不再使用的内存。这个过程在 JS 中是自动的，程序员无需关心。然而真是这个“自动”释放内存的特性，使得 JS 的很多初学者以为不用关心内存管理问题。

回收栈内存很简单，只需对栈内存执行 `pop` 即可，也就是将栈顶指针向下移动。实际上内存中也不是真的“删除”了被 `pop` 了的这个数据，只是告诉内存分配器这块内存可以被覆盖了。

回收堆内存就比较复杂了。不同的浏览器实现的垃圾回收机制也不一样，但是大致都是基于标记清除 (mark-and-sweep) 算法。这个算法的基本思路是，先标记所有的活动对象，然后清除所有的未标记对象。