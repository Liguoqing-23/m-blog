# 数据结构基本概念

## 数据结构的定义及相关

### 数据

数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据时计算机程序加工的原料。

### 数据元素、数据项

数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。

> [!tip]
>
> -   一个学生的信息，包括学号姓名、性别年龄、成绩等数据项，这些数据项组成一个学生的数据元素。
> -   往往在实际开发中，数据元素也可以成为另一个数据元素的数据项。

### 数据结构、数据对象

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据对象是具有相同性质的数据元素的集合，是数据的一个子集。

> [!tip]
>
> -   如：对于一个学生的数据元素，包括学号姓名、性别年龄、成绩等数据项，这些数据项之间的关系就构成了数据结构。而所有学生的数据元素构成了一个数据对象，当然也可以是子集。
> -   数据结构更专注于数据元素之间的关系，而数据对象更专注于数据元素共有的性质。
> -   数据对象是数据元素的集合，是数据的子集，是某一数据结构的实例化对象的集合。

```typescript
// 数据结构
interface Student {
    id: number;
    name: string;
    // ... 数据项
}

// 数据对象
const students: Student[] = [
    { id: 1, name: "Tom" },
    { id: 2, name: "Jerry" },
    // ... 数据元素，或称“记录”
];

// 以上统称为数据
```

## 数据结构三要素

数据结构三要素是在之后的数据结构学习中，对于所遇到的每钟数据结构都会进行分析的三个要素，包括逻辑结构、物理结构和数据的运算。

### 逻辑结构

逻辑结构是指数据对象中数据元素之间的相互关系。逻辑结构分为集合、线性结构、树形结构、图结构等。

### 物理结构

物理结构是指数据的逻辑结构在计算机中的存储形式。物理结构分为顺序存储结构、链式存储结构、索引存储结构、散列存储结构等。

-   顺序存储结构中各个数据元素在逻辑上相邻，物理上也相邻。非顺序存储结构则可以离散。
-   存储结构的选择取决于数据的特点、运算的要求、存储空间的要求和存取时间的要求。

### 数据的运算

数据的运算是指对数据元素进行的操作。数据运算包括运算的定义、运算的实现和运算的性能分析。

-   运算的实现与数据的存储结构有关，不同的存储结构适合不同的运算。

## 数据类型和抽象数据类型

### 数据类型

数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

-   原子类型：不可再分解的基本类型，如整型、实型、字符型等。
-   结构类型：由若干个类型组合而成的类型，如数组、结构、共用体等。

::: code-group

```typescript
// 原子类型
let num: number = 1;

// 结构类型
interface Point {
    x: number;
    y: number;
}
```

```c
// 原子类型
int num = 1;

// 结构类型
struct Point {
    int x;
    int y;
};
```

:::

### 抽象数据类型 ADT

抽象数据类型是指一个数学模型及定义在该模型上的一组操作。ADT 仅指数据类型的逻辑结构和运算，而不涉及数据的存储结构。

-   ADT 是数据类型的数学抽象，是数据类型的逻辑定义。
-   数据类型是 ADT 的实现，是 ADT 的物理实现。

::: code-group

```typescript
// 抽象数据类型
interface Stack<T> {
    push(item: T): void;
    pop(): T;
    // ... 其他操作
}

// 数据类型
class ArrayStack<T> implements Stack<T> {
    private items: T[] = [];

    push(item: T): void {
        this.items.push(item);
    }

    pop(): T {
        return this.items.pop();
    }
}
```

```c
// 抽象数据类型
typedef struct {
    int *items;
    int top;
} Stack;

void push(Stack *stack, int item);
int pop(Stack *stack);
// ... 其他操作

// 数据类型
void push(Stack *stack, int item) {
    stack->items[++stack->top] = item;
}

int pop(Stack *stack) {
    return stack->items[stack->top--];
}
```

:::
