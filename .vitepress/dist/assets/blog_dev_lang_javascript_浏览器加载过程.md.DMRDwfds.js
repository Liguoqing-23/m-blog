import{_ as t,D as n,a4 as e,am as s,$ as a,C as c}from"./chunks/framework.BDOtvRbC.js";const m=JSON.parse('{"title":"浏览器加载过程","description":"","frontmatter":{},"headers":[],"relativePath":"blog/dev_lang/javascript/浏览器加载过程.md","filePath":"blog/dev_lang/javascript/浏览器加载过程.md"}'),d={name:"blog/dev_lang/javascript/浏览器加载过程.md"},l=s('<h1 id="浏览器加载过程" tabindex="-1">浏览器加载过程 <a class="header-anchor" href="#浏览器加载过程" aria-label="Permalink to &quot;浏览器加载过程&quot;">​</a></h1><h2 id="浏览器解析和渲染" tabindex="-1">浏览器解析和渲染 <a class="header-anchor" href="#浏览器解析和渲染" aria-label="Permalink to &quot;浏览器解析和渲染&quot;">​</a></h2><div class="note custom-block github-alert"><p class="custom-block-title">参考</p><p><a href="https://web.dev/articles/howbrowserswork" target="_blank" rel="noreferrer">https://web.dev/articles/howbrowserswork</a></p><p>本文发布于 2011 年。可能内容大多已不准确，但是推荐仔细阅读。</p></div>',3),r=s(`<p>当浏览器获取到 HTML 文件后，会进行解析，解析过程分为两个阶段：解析 HTML 和解析 CSS。解析 HTML 时，浏览器会将 HTML 文件解析成 DOM 树，解析 CSS 时，浏览器会将 CSS 文件解析成 CSSOM 树。解析完成后，浏览器会将 DOM 树和 CSSOM 树合并成一个渲染树 (Render Tree)，然后根据渲染树来进行布局 (layout) 和绘制 (paint)。</p><h2 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h2><p>第一次确定节点的大小位置称为 <code>layout</code>，之后对节点的大小位置重新计算修改称为回流 <code>reflow</code>。DOM 结构、布局、窗口大小的改变以及调用 <code>getCumputedStyle</code> 等获取尺寸和位置信息的方法时都会引起回流。</p><p>第一次渲染内容称为 <code>paint</code>，之后重新渲染称为重绘 <code>repaint</code>。改变颜色、背景、边框等样式时会引起重绘。</p><p>回流一定会引起重绘，重绘不一定会引起回流。</p><h3 id="回流优化" tabindex="-1">回流优化 <a class="header-anchor" href="#回流优化" aria-label="Permalink to &quot;回流优化&quot;">​</a></h3><ul><li>避免频繁操作 DOM</li><li>避免频繁操作样式，可以使用 <code>class</code> 一次性修改样式（虚拟 DOM 也是这样做的）</li><li>避免频繁获取布局信息</li><li>使用 <code>float</code> 或 <code>position: fixed</code> 定位的元素会减小开销，不会引起其他元素回流</li></ul><h2 id="合成和性能优化" tabindex="-1">合成和性能优化 <a class="header-anchor" href="#合成和性能优化" aria-label="Permalink to &quot;合成和性能优化&quot;">​</a></h2><p>合成 (composite) 是浏览器的一种优化技术，它可以将页面的各个层合成为一个图层。有些属性会创建新的合成层，例如 <code>transform</code>、<code>opacity</code>、<code>filter</code>、<code>will-change (实验性)</code>、<code>video</code>、<code>canvas</code>、<code>iframe</code>、<code>webgl</code>、<code>position: fixed</code>、<code>position: sticky</code>等。好处在于可以通过 GPU 独立绘制，不会影响其他层，可以提高渲染性能。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">/* 通过 transform 使动画元素形成新合成层 */</span></span>
<span class="line"><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">.container</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> {</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">    /* any styles */</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    transition</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">: </span><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;">all</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;"> 0.3</span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">s</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">.container:hover</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> {</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">    /* any defferent styles */</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    transform</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">: </span><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;">translateZ</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;">0</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">);</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">}</span></span></code></pre></div><h2 id="defer-和-async" tabindex="-1">defer 和 async <a class="header-anchor" href="#defer-和-async" aria-label="Permalink to &quot;defer 和 async&quot;">​</a></h2><p>当浏览器解析到 <code>script</code> 时，会暂停解析 HTML，先加载并执行 <code>script</code>。只有等到 <code>script</code> 执行完毕后，才会继续解析 HTML，称为阻塞。</p><p>之所以这样，是因为 <code>script</code> 可能会修改 DOM 结构，如果浏览器继续解析 HTML，可能会导致 <code>script</code> 修改的 DOM 结构不一致，会造成严重的回流和重绘，极大的消耗性能。</p><p>对于现在的组件化开发，基本都是脚本执行大量的 DOM 操作，如果还是阻塞式加载，会导致页面加载速度变慢，用户体验变差。</p><p><code>defer</code> 和 <code>async</code> 两个属性都是用来控制 <code>script</code> 的加载和执行的。</p><h3 id="defer" tabindex="-1">defer <a class="header-anchor" href="#defer" aria-label="Permalink to &quot;defer&quot;">​</a></h3><p><code>defer</code> 属性告诉浏览器无需等待脚本加载和执行，可以继续解析 HTML，构建 DOM Tree。这样就取消了阻塞。如果脚本提前加载完毕，会等待 DOM Tree 构建完毕，并在 <code>DOMContentLoaded</code> 事件触发前执行。多个 <code>defer</code> 脚本按照加载顺序执行。</p><p><code>defer</code> 可以提升页面一定的性能，将 <code>defer</code> 放到 <code>&lt;head&gt;</code> 中，可以让浏览器抓紧加载脚本，然后继续构建 DOM，二者同时进行。</p><p><code>defer</code> 仅适用于外部脚本，内联脚本会忽略 <code>defer</code> 属性。因为只有外部脚本才需要加载，内部加 <code>defer</code> 没有意义。</p><h3 id="async" tabindex="-1">async <a class="header-anchor" href="#async" aria-label="Permalink to &quot;async&quot;">​</a></h3><p><code>async</code> 也不会阻塞页面渲染，可以让脚本完全独立，独立加载、独立运行，不会等待其他脚本。多个 <code>async</code> 脚本执行顺序不确定。</p><p><code>async</code> 加载完毕会立即执行，不会等待 DOM 构建完毕。所以在 <code>async</code> 操作 DOM 是危险的。</p>`,22);function p(h,k,F,_,f,y){const i=a("auto-dark"),o=a("show-image");return c(),n("div",null,[e(i),l,e(o,{src:"/img/浏览器加载过程-1.png"}),r])}const u=t(d,[["render",p]]);export{m as __pageData,u as default};
