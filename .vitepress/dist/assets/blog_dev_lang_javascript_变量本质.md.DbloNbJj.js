import{_ as s,D as i,C as a,am as n}from"./chunks/framework.BDOtvRbC.js";const y=JSON.parse('{"title":"变量本质","description":"","frontmatter":{},"headers":[],"relativePath":"blog/dev_lang/javascript/变量本质.md","filePath":"blog/dev_lang/javascript/变量本质.md"}'),t={name:"blog/dev_lang/javascript/变量本质.md"},l=n(`<h1 id="变量本质" tabindex="-1">变量本质 <a class="header-anchor" href="#变量本质" aria-label="Permalink to &quot;变量本质&quot;">​</a></h1><p>变量是什么？变量到底是什么？</p><p>在刚接触 JS 时，往往讲师都是从变量开始讲起，无论是 C/C++ 也好，Java 也罢，知道我接触到了 JS，在 mooc 打开了一节免费的课程，仍然是从变量开始讲起这门语言的基础。</p><p>随着不断学习，从编写简单逻辑，到构建复杂业务，我一直在向前走着，似乎提起变量的次数也少了。即便仍然不断写着 <code>const</code>、<code>let</code>，却是肌肉记忆，大多思考的是变量名如何起的更见名知意，而不是变量前的那个关键字究竟为何。</p><h2 id="藏躲在背后的空间——内存" tabindex="-1">藏躲在背后的空间——内存 <a class="header-anchor" href="#藏躲在背后的空间——内存" aria-label="Permalink to &quot;藏躲在背后的空间——内存&quot;">​</a></h2><p>谈起变量，便不得不提内存。无论是 C/C++ 还是 JS 还是任何一种语言，内存的什么周期都是分配 (allocate)、使用 (use)、释放 (release)。</p><p>在 JS 中，变量被分为了两种，一种是原始类型 (primitive type)，另一种是引用类型 (reference type)。原始类型包括了 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code>、<code>bigint</code>，引用类型则包括了 <code>object</code>、<code>array</code>、<code>function</code>。</p><p>原始类型存在于栈内存 (stack memory)。之所以如此，是从栈的特点考虑的，栈结构性强、内存连续，所以栈内存的分配和释放都很快。但是栈内存的空间是比较小的。</p><p>基于此，原始类型的大小是<strong>固定的</strong>，且<strong>值不可变</strong>。修改变量的值，实际上是重新分配了一块内存空间。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;"> 1</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> b </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">b </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;"> 2</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span></code></pre></div><p>在这段代码中，a 和 b 都是原始类型，所以 a 和 b 都是存储在栈内存中。下面演示一下程序运行时栈内存的变化：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;"> 1</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// stack: a: 1</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> b </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a;</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// stack: a: 1, b: 1</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">b </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;"> 2</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// stack: a: 1, _, b: 2</span></span>
<span class="line"><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// stack: a: 1, b: 2</span></span></code></pre></div><ul><li>当 b 被赋值为 a 时，其实是从栈内存中复制了 a 的值，然后将这个值赋给了 b。</li><li>当 b 被赋值为 2 时，其实是给 b 分配了新的内存空间，而不是修改了原来的内存空间。而 <code>_</code> 则是由垃圾回收机制解决的。</li></ul><p>引用类型则是存储在堆内存中，堆内存的分配和释放都比较慢，但是堆内存的大小是没有限制的。</p><p>在 JS 中，引用类型就是对象 (object)。按照官方的说法，对象是指内存中的可以被标识符应用的一块区域。对象是 JS 中唯一可变的值，意味着对象可以修改内存中的数据。</p><p>要解释上面这段话，首先要理解对象是如何存在内存中的。对象是由键值对组成的，存储在堆内存 (heap memory) 中，而对象的引用则是存储在栈内存中的。我们编写程序只能够通过栈内存中的引用来操作堆内存中的对象，而不能直接操作堆内存中的对象。</p><p>堆内存的寻址非常快，所以堆内存操作利于对象的增删改查，且堆内存的空间是比较大的。但是堆内存的分配和释放都比较慢。</p><h2 id="变量在内存中的初始化" tabindex="-1">变量在内存中的初始化 <a class="header-anchor" href="#变量在内存中的初始化" aria-label="Permalink to &quot;变量在内存中的初始化&quot;">​</a></h2><p>JS 定义变量时就已经在内存中分配了空间。对于原始变量类型，如 <code>n = 123</code>、<code>s = &quot;abc&quot;</code>，变量名和值都存储在栈内存中。对于引用变量类型，如 <code>o = { name: &quot;a&quot; }</code>、<code>a = [1, 2, 3]</code>，变量名存储在栈内存中，而值则存储在堆内存中。</p><p>而函数作为一种特殊的引用类型，其实也是存储在堆内存中的。函数名存储在栈内存中，而函数体则存储在堆内存中。</p><h2 id="深拷贝、浅拷贝" tabindex="-1">深拷贝、浅拷贝 <a class="header-anchor" href="#深拷贝、浅拷贝" aria-label="Permalink to &quot;深拷贝、浅拷贝&quot;">​</a></h2><p>在 JS 中经常会遇到深拷贝和浅拷贝的问题。深拷贝和浅拷贝的区别在于是否复制了引用类型的值。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> { name: </span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;">&quot;a&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">， age: </span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;">18</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">， friend: { name: </span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;">&quot;b&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> } };</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> c </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">c.name </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;"> &quot;c&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">console.</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">log</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(a.name); </span><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// c</span></span></code></pre></div><p>修改 c 的 name 属性时，实际上是修改了 a 的堆内存中的对象，所以 a 的 name 属性也被修改了。这就是浅拷贝。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">function</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;"> deepClone</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(</span><span style="--shiki-light:#FD971F;--shiki-dark:#FD971F;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">obj</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">) {</span></span>
<span class="line"><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">    if</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> (</span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">typeof</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">!==</span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;"> &quot;object&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">) </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">return</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj;</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> result </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> Array.</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">isArray</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(obj) </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">?</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> [] </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">:</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> {};</span></span>
<span class="line"><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">    for</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> (</span><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> key </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">in</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">        if</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> (obj.</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">hasOwnProperty</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(key)) {</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">            result[key] </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;"> deepClone</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(obj[key]);</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">        }</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">    }</span></span>
<span class="line"><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">    return</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> result;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">}</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> a </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> { name: </span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;">&quot;a&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">， age: </span><span style="--shiki-light:#AE81FF;--shiki-dark:#AE81FF;">18</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">， friend: { name: </span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;">&quot;b&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> } };</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> b </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;"> deepClone</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(a);</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">b.friend.name </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;"> &quot;c&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">console.</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">log</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">(a.friend.name); </span><span style="--shiki-light:#88846F;--shiki-dark:#88846F;">// b</span></span></code></pre></div><p>这段代码使用了递归的方式实现了深拷贝。修改 b 的 friend.name 属性时，实际上是修改了 b 的堆内存中的对象，所以 a 的 friend.name 属性没有被修改。这就是深拷贝。</p><p>当然这只是用 <code>typeof</code> 简单实现了深拷贝，实际上 <code>typeof</code> 也是有局限性的，比如 <code>typeof null</code> 会返回 <code>object</code>，所以这段代码并不是完全正确的。</p><p>深拷贝是一个非常复杂的问题，有很多种实现方式，比如 JSON.parse(JSON.stringify(obj))、lodash 的 _.cloneDeep(obj) 等，往后可以再深入研究。</p><h2 id="变量的内存释放" tabindex="-1">变量的内存释放 <a class="header-anchor" href="#变量的内存释放" aria-label="Permalink to &quot;变量的内存释放&quot;">​</a></h2><p>JS 如同 JVM 一样，嵌入了垃圾回收机制。垃圾回收机制主要任务是跟踪内存的分配和使用，它会在内存不再使用时，自动释放不再使用的内存。这个过程在 JS 中是自动的，程序员无需关心。然而真是这个“自动”释放内存的特性，使得 JS 的很多初学者以为不用关心内存管理问题。</p><p>回收栈内存很简单，只需对栈内存执行 <code>pop</code> 即可，也就是将栈顶指针向下移动。实际上内存中也不是真的“删除”了被 <code>pop</code> 了的这个数据，只是告诉内存分配器这块内存可以被覆盖了。</p><p>回收堆内存就比较复杂了。不同的浏览器实现的垃圾回收机制也不一样，但是大致都是基于标记清除 (mark-and-sweep) 算法。这个算法的基本思路是，先标记所有的活动对象，然后清除所有的未标记对象。</p>`,32),F=[l];function h(k,e,p,d,r,o){return a(),i("div",null,F)}const g=s(t,[["render",h]]);export{y as __pageData,g as default};
