import{_ as l,D as r,a4 as a,R as e,G as h,am as s,$ as i,C as o}from"./chunks/framework.BDOtvRbC.js";const v=JSON.parse('{"title":"GC 算法","description":"","frontmatter":{},"headers":[],"relativePath":"blog/dev_lang/javascript/GC 算法.md","filePath":"blog/dev_lang/javascript/GC 算法.md"}'),p={name:"blog/dev_lang/javascript/GC 算法.md"},c=e("h1",{id:"gc-算法",tabindex:"-1"},[h("GC 算法 "),e("a",{class:"header-anchor",href:"#gc-算法","aria-label":'Permalink to "GC 算法"'},"​")],-1),k=s('<div class="note custom-block github-alert"><p class="custom-block-title">以后认真读一读</p><p><a href="https://deepu.tech/memory-management-in-v8/" target="_blank" rel="noreferrer">https://deepu.tech/memory-management-in-v8/</a></p><p><a href="https://v8.dev/blog/trash-talk" target="_blank" rel="noreferrer">https://v8.dev/blog/trash-talk</a></p><p><a href="https://juejin.cn/post/6934645755080605710" target="_blank" rel="noreferrer">https://juejin.cn/post/6934645755080605710</a></p></div>',1),F=s(`<h2 id="引用计数-reference-counting" tabindex="-1">引用计数 Reference counting <a class="header-anchor" href="#引用计数-reference-counting" aria-label="Permalink to &quot;引用计数 Reference counting&quot;">​</a></h2><p>引用计数就是当一个对象有一个引用指向它时，那么这个对象的引用 +1，当引用失效时，引用 -1，当引用计数为 0 时，就可以被回收。</p><p>引用计数算法最大的弊端是会产生循环引用，导致内存泄漏。如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes monokai monokai vp-code"><code><span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">function</span><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;"> test</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">() {</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj1 </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> {};</span></span>
<span class="line"><span style="--shiki-light:#66D9EF;--shiki-dark:#66D9EF;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    let</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj2 </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> {};</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">    obj1.name </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj2;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">    obj2.name </span><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">=</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;"> obj1;</span></span>
<span class="line"><span style="--shiki-light:#F92672;--shiki-dark:#F92672;">    return</span><span style="--shiki-light:#E6DB74;--shiki-dark:#E6DB74;"> &quot;test&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">}</span></span>
<span class="line"><span style="--shiki-light:#A6E22E;--shiki-dark:#A6E22E;">test</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#F8F8F2;">();</span></span></code></pre></div><h2 id="标记清除-mark-sweep" tabindex="-1">标记清除 Mark-Sweep <a class="header-anchor" href="#标记清除-mark-sweep" aria-label="Permalink to &quot;标记清除 Mark-Sweep&quot;">​</a></h2><p>可达性 Reachability，是标记清除算法的核心概念。从根开始，递归遍历所有引用的对象，标记所有可达对象（被引用对象），然后清除所有未标记的对象（未被引用对象）。垃圾回收器会定期执行这个算法。</p><h2 id="标记压缩-mark-compact" tabindex="-1">标记压缩 Mark-Compact <a class="header-anchor" href="#标记压缩-mark-compact" aria-label="Permalink to &quot;标记压缩 Mark-Compact&quot;">​</a></h2><p>类似于标记清除，但是在清除之后，会将存活的对象移动到一端，整合空间空间为连续空间，然后清除另一端的内存。</p><h2 id="分代回收-generational-collection" tabindex="-1">分代回收 Generational Collection <a class="header-anchor" href="#分代回收-generational-collection" aria-label="Permalink to &quot;分代回收 Generational Collection&quot;">​</a></h2><p>分代回收是一种优化算法，根据对象的存活时间将内存分为几块，一般分为新生代和老生代。新生代的对象存活时间较短，老生代的对象存活时间较长。新生代的对象使用标记清除算法，老生代的对象使用标记压缩算法。</p><p>新生代的对象一般使用 Scavenge 算法，将内存分为两块，一块为对象区域，一块为空闲区域。当对象区域满了之后，将存活的对象复制到空闲区域，然后交换两块区域的角色。</p><p>老生代的对象一般使用标记清除和标记压缩算法。</p><h2 id="增量标记-incremental-marking" tabindex="-1">增量标记 Incremental Marking <a class="header-anchor" href="#增量标记-incremental-marking" aria-label="Permalink to &quot;增量标记 Incremental Marking&quot;">​</a></h2><p>增量标记是为了减少垃圾回收的停顿时间，将标记清除算法分为多个阶段，每个阶段执行一部分标记工作，然后让程序执行一段时间，然后再执行下一个阶段的标记工作。</p><h2 id="闲时回收-idle-time-garbage-collection" tabindex="-1">闲时回收 Idle-time Garbage Collection <a class="header-anchor" href="#闲时回收-idle-time-garbage-collection" aria-label="Permalink to &quot;闲时回收 Idle-time Garbage Collection&quot;">​</a></h2><p>闲时回收是为了减少垃圾回收对程序执行的影响，将垃圾回收的工作放到程序空闲的时候执行。</p>`,16);function d(g,m,_,b,u,y){const t=i("auto-dark"),n=i("show-image");return o(),r("div",null,[c,a(t),k,a(n,{src:"https://i.imgur.com/kSgatSL.png"}),F])}const C=l(p,[["render",d]]);export{v as __pageData,C as default};
